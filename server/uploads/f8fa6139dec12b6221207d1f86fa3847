
# 知识总结

## 前端

### CSS

1. 两种盒子模型分辨说下
   1. content-box（w3c 反 IE 搞的，标准盒模型）: 最终宽高是内容区宽高
   2. border-box（IE 5，又称怪异盒模型，其实这才标准的，用的最多）: 最终宽高 是 内容区宽度 + 内边距（padding）宽度 + 边框（border） 宽度（*{box-sizing:border-box;}）
1. css reset 和 normalize.css 区别（考英语 😂）？
   - reset：重置，抛弃默认样式
   - normalize（正常化）：让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一
1. 如何垂直居中
   - 平时总结：
     - 水平居中：
       - 内联：父节点上写 text-align:center;   （center，c 在e.i.y 前发 /s/：森特）
       - 块级：margin-left: auto; margin-right: auto;
     - 垂直居中： https://jscode.me/t/topic/1936

     ```css
     <!-- 方法一：垂直元素绝对定位，top left right bottom 都设 0，margin：auto，缺点：必须定义宽高 -->
     div{
        width:200px;
        height:200px;
        background: red;
        position:absolute;
        top:0;
        right:0;
        bottom:0;
        left:0;
        margin:auto;
     }
     <!-- 方法二：前提知道垂直元素的大小，垂直元素 相对于父元素宽高 50%，相对自己 margin-top margin-left 各减去一半 -->
     div{
        width:400px;
        height:400px;
        background: red;
        position:absolute;
        top:50%;
        left:50%;
        margin-top:-200px;
        margin-left:-200px;
     }

      <!-- 方法三：垂直元素相对定位 相对于父元素宽高 50%，相对自己 使用 transform 的 translate 位移自己大小负一半，不需要知晓宽高 -->
      div{
        width:200px;
        height:200px;
        background: red;
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
      }

      <!-- 方法四：flex  -->
      div{
         height:800px;
         display:flex;
         <!-- 水平的主轴 x 轴 居中， justify：网络译：为…辩护（证明）；使每行两端对齐-->
         justify-content:center;

         <!-- 垂直的交叉轴 y 轴 居中-->
         align-items:center;
         border:1px #ccc solid;
      }

      <!-- 或者 flex 使用 margin:auto -->
      <!-- div{
         height:800px;
         display:flex;
         margin:auto;
         border:1px #ccc solid;
      } -->

      div.child{
         width:200px;
         height:200px;
      }
     ```

1. [flax](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html) 怎么用，常用属性
   - 容器属性：
      - **flex-direction** 属性决定主轴的方向（即项目的排列方向）。
        - row (默认) 主轴为水平方向 左到右 | row-reverse 右到左
        - column 主轴为垂直方向 上到下 | column-reverse 下到上
      - **flex-wrap** 如果一条轴线排不下，如何换行。
        - nowrap（默认）不换
        - wrap 换，第一行在上方
        - wrap-reverse 换，第一行在下方
      - **flex-flow** 是上面两个属性缩写 ： flex-flow：<flex-direction> || <flex-wrap>;
      - **justify-content** 主轴对其方式：flex-start（默认）左对齐，flex-end：右，center：居中，space-between：两端对齐。。。
      - **align-items**  交叉轴对其方式：flex-start 上，flex-end：下，center：交叉轴的中点对齐。stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。
   - 项目属性：
     - order：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
     - flex-grow（长大，扩大）：项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
     - flex-shrink（缩小 /丝润可/）：项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
     - flex-basis（基点，/倍射思/）：在分配多余空间之前，项目占据的主轴空间。默认值为 auto，即项目的本来大小
     - flex：flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 **0 1 auto**。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

1. CSS 优先级
   - 选择器越具体，优先级越高。!important > 行内 > #id > .class = 伪类（:link :hove）= 属性 > 元素 = 伪元素（::before） > 通配
   - 外部样式 = 内部样式，同样优先级，写在后面的覆盖前面的。
   - !important; 优先级最高；但如果是 `width:100px !important;`  `min-width:200px;` 会覆盖 !important

1. BFC FC（Formatting Contexts）译为：格式上下文，它是页面中的一块渲染区域，并有一套渲染规则；BFC 就是 Block Fromattin Contexts 块级格式上下文，还有 IFC（inline FC）内联格式上下文,文本渲染规则；如不能存在块级元素p，FFC(Flex FC) 自适应格式化上下文,GFC（GridLayout FC）网格布局格式化上下文,更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制
   - 块级格式上下文 （通俗讲就是一个结界），主要的作用：
      - **清除浮动**：overflow:hidden .clearfix 清除浮动
      - 防止同一 BFC 容器中的相邻元素间的外边距重叠问题，overflow:hidden [**取消父子 margin 合并**](http://jsbin.com/conulod/1/edit?html,css,js,output) 用 padding-top: 1px;
   - 触发 BFC 特性：
     - body 根元素
     - 浮动元素：float 除 none 以外的值
     - 绝对定位：postion（absolute、fixed）
     - display 为 inline-box、table-cells、flex
     - overflow 除了 visible 以外的值（hidden、auto、scroll）

1. 清除浮动
   1. 直接设置父元素高度。优点简单，缺点得知道父元素高度。
   2. 父元素直接设置 overflow:hidden 或 auto。优点简单，缺点有内容要溢出显示(弹出菜单)，也会被一同隐藏。
   3. 把父元素也设置为浮动。优点简单，缺点对后续元素会有影响。
   4. 在父元素中，追加空子元素，并设置其 clear 属性为 both。优点：clear 是 css 中专用于清除浮动的属性。缺点添加无意义的空标签。
   5. 使用内容生成的方式清除浮动。优点：不破坏文档结构，没有副作用，规范清除浮动。缺点：代码多

      ```css
      <!-- .clearfix 清除浮动写在父元素上 -->
      .clearfix ::after{
         content: '';
         display: block;
         clear:both;
      }
      .clearfix{
         zoom: 1; /* IE 兼容 */
      }
      ```

### HTML

块元素: 大多为结构性标记：独占一行(从上到下排版);可设置宽高，可以嵌套其他元素 ，（p、dt 元素不能嵌套其他元素）
行类元素: 大多为描述性标记，从左到右一行显示;设置宽高无效

1. 语义化：
  合适的位置用合适标签，段落用 `P` 标签，标题用 `H1 ~ H6` 标签，文章用 `Article` 标签等，目的使 HTML 具有更高的可读性，也有利 SEO 收录。

1. mate viewport 是做什么用的，怎么写？
  移动端开发时候，使移动设备设配页面 一条配置，可以参考淘宝 移动端页面；

   `<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;">`

   user-scalable：yes/no | 定义是否允许用户手动缩放页面，默认值yes

1. [canvas](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API) 用来干嘛的
   `<canvas>`元素可被用来通过 JavaScript（Canvas API 或 WebGL API）绘制图形及图形动画。

1. offset：相对于容器距离，client：可视区域距离，scroll：整个页面，包括隐藏区域（滚动条）

### JavaScript

1. 基本类型（送命题）
   - string，number，boolean，null，undefined，symbol，BigInt，object
   - 一旦出现 array，function，Math，Reg, Date，NaN... 就 GG
   ![为什么说 JavaScript 函数一等公民](https://cdn.jsdelivr.net/gh/w3ctim/picBed/blog/notes/20200420203645.png)

1. 宏任务和微任务，通常会给出一段代码，让你给出输出结果，并解释？

![event loop](./_media/question/event_loop.jpeg)

1. 解释 JavaScript 的单线程模型，以及为什么这样设计？setTimeout 的延时为何做不到精确？
  避免`DOM`渲染冲突; 浏览器需要渲染`DOM`, `JS` 可以修改`DOM`, `JS`执行的时候,浏览器`DOM`渲染会暂停, 两段`JS`也不能同时执行(都修改`DOM`就冲突了)

1. Promise

   - Promise 值穿透

      ```js
      Promise.resolve(1)
      .then(2)
      .then(Promise.resolve(3))
      .then(console.log)
      // 1
      ```

      解释：`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值穿透。

      ```js
      Promise.resolve(1)
      .then(function(){return 2})
      .then(Promise.resolve(3))
      .then(console.log)
      // 2

      Promise.resolve(1)
      .then(function(){return 2})
      .then(function(){return Promise.resolve(3)})
      .then(console.log)
      // 3
      ```

      Promise 方法链通过 `return` 传值，没有 `return` 就只是相互独立的任务而已

   - 状态中转

      ```js
      let p1= new Promise((resolve,reject)=>{
         reject("失败");
      });
      let p2 = new Promise((resolve,reject)=>{
         resolve(p1) // 状态中转
      }).then(
         (msg) => {console.log(`resolve: ${msg}`)},
         (err) => {console.log(`rejuct: ${err}`)}
      ).then(a=>console.log('成功'),b=>console.log('失败'))
      // rejuct: 失败
      // 成功
      ```

      - **then 也是 Promise，不管是第一个参数返回，还是第二个参数返回，会默认返回 resolved（成功状态）**（then 肯定得是个对象，要不然怎么链式操作呢）
      - 此时 p2 是个 Promise, 状态：resolved，最后一个 `.then` 里面没有返回值，只执行打印了`成功`，所以返回是 undefined (`Promise {<resolved>: undefined}`)

      ```js
      var p1 = new Promise((resolve, reject) => {
         reject('p1 失败');
      }).then(() => { },() => { });

      var p2 = new Promise((resolve, reject) => {
         resolve(p1);
      }).then(result => {
         console.log('微任务2的成功:' + result);
      }, error => {
         console.log('微任务2的失败:' + error);
      });
      // 微任务2的成功:undefined
      ```

      p1 执行了 `.then`, 且也写了第二参数，所以失败状态被执行了，p1 `.then` 没有返回任何数据，所以最终 p1 返回的是一个新的、状态为 `resoled` 值为 `undefined` 的 Promise，注意 p1 构造函数里返回是 `rejected`，如果 p1 的 `.then` 的第二参数没写（接收处理），还是会把 rejected 状态往 p2 传递的，打印：`微任务2的失败：p1 失败`

      ```js
      var p1 = new Promise((resolve, reject) => {
         // resolve('成功');
         console.log('1');
         reject('失败');//主线程代码
      });

      var p2 = p1.then(
          result => { },
          error => { console.log('aaa'); }
      );//then 肃然也是个 promise 但属于微任务队列
      console.log('2');
      console.log(p1);//p1 执行了吗？答案是执行了，状态是 rejected
      console.log(p2);//p2 执行了吗？答案是没有。状态是 pending

       //把这个任务丢到任务队列，等 1 秒，代码继续只能给
        setTimeout(() => {
            console.log(p2);//p2 执行了吗？答案-->执行了
        }, 1000);
      ```

   - catch：`Promise.prototype.catch()` 方法是 `.then(null, rejection)` 或 `.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数；是个语法糖，免去链式操作每个 `.then` 都要写第二参数

     ```js
      var p1 = new Promise((resolve, reject) => {
         // 如果我先执行，你们都没戏
         // resolve(1)

         // 1. reject
         reject('失败');
         // 2. 自定义错误
         throw new Error("fail");
         // 3. 语法或运行错误, x 没声明
         resolve(x + 1)
         // catch 都会捕获的，但是，如果先执行 resolve 的话，错误是不会返回的，因 Promise 只有一个状态
      }).then(r=>{
         // 这里是第一个参数，只有上返回成功状态，才会执行；so 这里代码不会执行
         console.log(1);
         return Promise.resolve('foo')
      })
      .then(null,
            e => {
               // 如果有链式操作中有 第二参数，会错误拦截，下面的 catch 不会执行
               console.log('对不起，我是差人! '+e)
            }
      ).catch(e => {
            console.log(e)
      }).then(fucntion(){
        console.log('要是这里 then() 方法里面报错，就与前面的 catch() 无关了。');
        // 所以 catch 一般是写在最后面
      })
      ```

   - all：方法是将多个 Promise 实例（数组形式），包装成一个新的 Promise 实例。全部 Promise `fulfilled` 才成功，有一个 `rejected` 就是失败。（比慢模式），并行的模式，将所有请求**一次性全部发送出去**，然后等待接收到全部结果后，按照**顺序**打印出来而已。

   - race：参数 all。只有其中一个**率先**改变状态，该状态就传递给新的 Promise。（比快模式）

   ```js
    // 实现 Promise all
    // 写法一  重点就是返回一个 Promise，在 Promise 里处理（判断结果长度）循环
    Promise.all2 = function (promises) {
      return new Promise((resolve, reject) => {
        let count = 0, len = promises.length;
        const result = new Array(len);
        for (let i = 0; i < len; i++) {
          promises[i].then(value => {
            count++;
            result[i] = value;
            if (result.length === count) {
              resolve(result);
            }
          }, error => reject(error))
        }
      })
    }
   // 写法二
    Promise.all = function (promises) {
      return new Promise((resolve, reject) => {
      let count = promises.length;
      const result = [];
      while (promises.length) {
         promises.shift().then(value => {
            result.push(value);
            if (result.length === count) {
               resolve(result);
            }
         }, error => reject(error))
       }
      })
    }

    let p1 = new Promise((resolve, reject) => {
      setTimeout(function () {
        resolve('1')
      }, 2000)
    })

    let p2 = new Promise((resolve, reject) => {
      setTimeout(function () {
        resolve('2')
      }, 3000)
    })

    let p3 = new Promise((resolve, reject) => {
      setTimeout(function () {
        reject('5')
      }, 3000)
    })

    console.time('cost')
    Promise.all2([p1, p2, p3]).then(data => {
      console.log(data)
      console.timeEnd('cost')
    })

   ```

2. async await（作用：把异步代码写成同步代码）
   async 函数返回类型为 Promise 对象： 这是和普通函数本质上不同的地方，也是使用时重点注意的地方；

   1. return `new Promise()`;这个符合 async 函数本意；
   2. return data;这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于 `Promise.resolve(data)` ；还是一个 Promise 对象，但是在调用 async 函数的地方通过简单的=是拿不到这个 data 的，因为返回值是一个Promise 对象，所以需要用 `.then(data => { })` 函数才可以拿到这个 data;
   3. 如果没有返回值，相当于返回了 `Promise.resolve(undefined)`;

   await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。

   如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。

   如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

   > 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。**async** 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。

   ```js
   (async function(){
      console.log(1)
      const flag = await new Promise(resolve=>{
         console.log(2)
         resolve(3)
         console.log(4)
      })
      console.log(flag)
      // async 内部还是会阻塞的
      // 得等待 Promise 执行后才能打印 5
      console.log(5)
   })() // → 1 2 4 3 5

   // 多个 Promise 怎么同步执行
   (async function(){
      // 这种写法 会造成 阻塞， 等 h1 执行完后，再执行 h2
      // 硬可以说这也是 async await 的缺点吧。。。 好多题目都其优缺点只能答这个了
      let h1 = await p1();
      let h2 = await p2();

      // 这种写法 会同时 执行 p1、p2
      let h1 = p1();
      let h2 = p2();
      let h1Value= await h1;
      let h2Value= await h2;

      // 或者 也是 同时 执行 p1、p2
      let res = await Promise.all([p1,p2]);
   })()
   ```

3. 实现 trim： `s.replace(/^\s+|\s+$/,'')`

4. JavaScript 如何实现继承
   - 原型链：每一个对象都有个隐式原型（`__proto__`），指向其构造函数的原型对象（`prototype`），并继承它属性与方法，同时原型对象（`prototype`）也有隐式原型，这样一层一层，最终指向 null，这就是原型链。

      ```js
      function parent(){
         this.PC = '玩家国度';
      }
      parent.prototype.playDotA= function(){
         console.log('羊刀赛高！');
      }

      function child(name){
         parent.apply(this,arguments);
         this.name =name;
      }

      child.prototype = Object.create(parent.prototype);
      child.prototype.playLOL = function(){
         console.log("7777~");
      }
      const son1 = new child('Tim');
      ```

   - extends 关键字

      ```js
         class parent{
            // 构造函数（实例化对象时调用的函数）
            constructor(){
               this.PC = '玩家国度'
            }
            playDotA(){
               console.log('羊刀赛高！')
            }
         }

         class child extends parent{
            constructor(name){
               // super() 就是调用父类的构造函数
               super();
               this.name = name;
            }
            playLOL(){
               console.log('777')
            }
         }
         const son2 = new child('Tim');
      ```

5. 怎么实现深拷贝，深浅拷贝区别？

     - `JSON.parse(JSON.stringify(data))` 缺点：data 得符合 JSON 规范；不能有 undefined（直接删除），funciton(直接删除)，引用，ReExp（转换成了空对象），Date（转换成了字符串）等，只能对象、数组、数值、字符串、布尔值和 null 。
     - 递归：
        1. 判断是否是对象，如果不是直接返回值；
        2. 如果普通对象判断 是数组还是普通对象，返回对象继续递归

        ```js
        // 深
        function deepCopy( value ) {
            // 复杂处理
            var target
            //如果不是对象的话直接返回
            if (!typeof value==='object' || value === null) return value;
            switch getType(value){
               case 'Aarry':
                  target=[];
                  break;
               case 'Function':
               // 这种写法只能保证 箭头函数 不报错
                  target = eval(object.toString())
                  break;
               case 'Date':
                  target=new Date(value);
                  break;
               case 'RegExp':
                  target=new RegExp(value)
                  break;
               case 'Object':
                  target = {}
                  break;
               // 还要 考虑 Set、Symbol、WeakMap、环。。。
               // 环就是对象循环引用，导致自己成为一个闭环： var a = {}; a.a = a;
               // 所以 JavaScript 的深拷贝是个深坑，日常开发中使用 JSON 的方法处理就差不多了。
            }

             // 简单处理
            if (!typeof value==='object'|| value === null) return value; //如果不是对象的话直接返回
            let target = Array.isArray( value ) ? [] : {} //数组兼容
            for (var k in value) {
                 target[k] =deepCopy(value[i]);
            }
            return target;
        }

         function getType(obj){
            return Object.prototype.toString.call(obj).slice(8,-1);
         }

        // 浅
        function clone(value){
        if (!typeof source==='object') return value;
              let target =  Array.isArray( value ) ? [...value] : {...value};
              return rs;
        }
        ```

   区别：浅，改变原始数据一通改变，深不会

6. 这段代码里的 this 是什么？
   - **直接赤裸裸调用方法** `fn()` 这种执行的代码，不管是在全局调用，还是在**方法体内**调用，就可以直接当成 `window.fn()`，this 就是 window，严格模式下就是 undefined，总结就是：**直接调用的方法的 this 的判断，在哪执行很重要，跟他在哪定义没关系！**
   - a.b.c.fn() 里面的 this 就是 a.b.c
   - new F() 里面的 this 就是新生成的实例
   - ES6 箭头函数 this 是上级作用域 this
   - 事件对象,在`DOM`事件中使用`this`，`this`指向了触发事件的 `DOM` 元素本身

   ```js
    document.addEventListener('xx',function(){
      // this 是 document
    })
    document.getElementById('div1').addEventListener('xx',function(){
      // this 是 ID 为 div1 元素
    })

   // 阿里题
   var a = 4;
   class A{
      a = 10;
      fn(){
         console.log(this.a)
      }
   }
   const b = new A().fn;
   b();

   // 这题的正确答案是 报错 Uncaught TypeError: Cannot read property 'a' of undefined
   // 因为 class 默认类体是 user strice, 严格模式。。。
   ```

   正确参考：[https://zhuanlan.zhihu.com/p/23804247](https://zhuanlan.zhihu.com/p/23804247)

7. 有点变态的面试题

   ```js
   function Foo(){
      getName = function(){
         console.log(1)
      }
      return this;
   }
   Foo.getName = function(){
      console.log(2);
   }
   Foo.prototype.getName = function(){
      console.log(3);
   }
   Foo.prototype.getAge = () =>{
      console.log(8);
   }
   var getName = function(){
      console.log(4);
   }
   function getName(){
      console.log(5);
   }
   Foo.getName();
   getName();
   Foo().getName();
   getName();
   new Foo.getName();
   new Foo().getName();
   new new Foo().getName();
   new new Foo().getAget();
   ```

   先变量提升 函数体提升
   `Foo = function...;  getName = func → 5`
   再代码执行
   `getName → 4` 覆盖 `getName → 5`
   打印：
   - `Foo.getName()` → **2**
   - `getName()` → **4**
   - `Foo().getName()` 是先执行 `Foo()`，Foo 内部 this 是 window，代码再执行，既 window 下的 `getName()` → 1，接着 return this，再`.getName()`，即输出 **1**；
   - `getName()` → **1**
   - `new Foo` 是无参数列表 new，`new Foo()` 是有参数列表 new，区别在于执行的优先级
   参考：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/**Operator_Precedence**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

     - `new Foo.getName()` 其中 `new Foo` 的优先级是 18，`Foo.getName()` 优先级是 19，所以就等同于 `new function(){ console.log(2) }`，既输出 **2**
     - `new Foo().getName()` 其中 `new Foo()` 的优先级是 19，`Foo.getName()` 优先级也是 19,从左到右执行，注意，Foo 方法体内 getName 前无 `this`，所以调用 prototype 上 `getName()` 输出 **3**
     - `new new Foo().getName()` 和上面一样，最后等于执行 `new func → 3`，输出 **3**
     - `new new Foo().getAget()` 报错，箭头函数不能实例化。。。

8. 箭头函数与普通函数的区别，构造函数可以使用 new 生成实例，那么箭头函数可以吗，为什么
   - 只有一个参数时小括号可省略,只有一行 return 是大括号可省略,如果返回的是对象类型 需要 () 包裹
   - 没有 this,它只会从自己的作用域链的上一层继承 this,(使用 call / apply 等任何方法都无法改变 this 的指向)
   - 没有 arguments (可用 ...args 展开(剩余)预算符代替)
   - 不被 new 执行，因为没有this、prototype

9. apply，call，bind 的区别

   - 初级回答（4 分）
   这三个函数都是改变了当前函数的 this 指向。
     - apply 接收的是数组，并会立即执行
     - call 接收的是用逗号隔开的参数，并会立即执行
     - bind 接收的是用逗号隔开的参数，但是不会立即执行，而是返回一个新的函数

   此时我的内心 OS：“妥妥的！心里美滋滋，正好是我准备的题目，下一题把”！
   but，此时面试官再次发问：“你能讲讲它们三个的实现原理吗？能自己实现一下这三个函数吗？”
   我：.....

   - 进阶回答（8分）
   我们重点讲一下 call 的用法和源码实现，其余的 apply 和 bind 道理一样。

     - call
     call 的基本用法

     ```js
     function add(c, d) {
        console.log(this.a + this.b + c + d);
     }
     var o = {a: 1, b: 2};
     add.call(o, 3, 4);
     ```

     如果我们不用 call，怎么实现这样的效果？

     ```js
     function add(c, d) {
        console.log(this.a + this.b + c + d);
     }
     var o = {a: 1, b: 2};
     // add.call(o, 3, 4);
     o.add = add;
     o.add(3, 4);
     delete o.add;
     ```

     我们能看到就三步：

     1. 把函数变成 object 的一个属性。
     2. 执行这个 object 下面的函数。
     3. 删除这个 object 下的这个函数。

     其实就是利用了，object 的属性的 this 指向该 object 的特性来实现的哦。

     我们尝试用源码实现一下

     ```js
     Function.prototype.call(context, ...args)
     {
        context = context || window;  // context 如果是 null，则指向 window
        context.fn = this;
        var result = context.fn(...args);
        delete context.fn;
        return result;
     }
     ```

     - apply
     apply 和 call 是一个道理

     ```js
     Function.prototype.apply(context, args)
     {
        context = context || window;
        context.fn = this;
        var result = context.fn(...args);
        delete context.fn;
        return result;
     }
     ```

     - bind
     bind 有一点特殊，但是道理都是一个道理。

     我们先写个例子看看 bind 怎么用

     ```js
     function add(c, d) {
        console.log(this.a + this.b + c + d);
     }
     var o = {a: 1, b: 2};
     var bindAdd = add.bind(o, 3);
     bindAdd(4);
     ```

     来看看源码怎么实现

     ```js
     Function.prototype.bind = function (context, ...rest) {
        var self = this;
        return function F(...args) {
           return self.apply(context, rest.concat(args)); // 两次的参数 rest，args 合并到一起，作为函数的参数
        }
     }
     ```

   此时我的内心 OS：“哈哈哈哈哈，我好机智，准备的太全了！”！
   面试官内心 OS：“还行吧，不过不要高兴的太早了。”
   面试官问：你能告诉下面程序的输出是什么吗？

   ```js
   function add(c, d) {
   console.log(this.a + this.b + c + d);
   }
   var o = {a: 1, b: 2};

   var bindAdd = add.bind(o, 3);
   new bindAdd(4);
   ```

   - 再次进阶（9 分）
   我们可以看到上面的程序仅仅是增加了一个 `new`，但是它的输出变成了 `NaN`，为什么？这是因为：" bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效"

   我们再来丰富下 `bind` 的实现

   ```js
   Function.prototype.bind = function (context, ...rest) {
      var self = this;

      return function F(...args) {
         /*如果是 new 的，则不要之前的 context 啦*/
         if (this instanceof F) {
               return self(...rest, ...args);
         }
         return self.apply(context, rest.concat(args));
      }
   }
   ```

10. 什么是立即执行函数、自执行函数？使用立即执行函数的目的是什么？或者题目是 模拟一个出 let

   ```js
   (function (){
      var name
   })()

   !!!!!!!function (){
      var name
   }()

   ~function (){
      var name
   }()
   ```

   目的：生成一个单独函数作用域，防止污染全局变量，避免变量冲突。

   ES 6 新语法
   {
      let  name
   }

11. 闭包，用途？ **内部函数被外部函数以外的变量引用时**✨，就形成了一个闭包，函数执行形成私有作用域，保存，保护变量不受全局作用域影响。

   ```js
   function foo() { // 外部函数
      var num  = 10;
      return function () { // 内部函数
         var age= 20;
         console.log(++num);
         console.log(++age);
      }
   }
   var f = foo(); // 以外的变量
   f(); //11 21
   f(); //12 21

    // [插装](https://zhuanlan.zhihu.com/p/54460682)
   function withHookAfter (originalFn, hookFn) {
      return function () {
         var output = originalFn.apply(this, arguments)
         hookFn.apply(this, arguments)
         return output
      }
   }
   ```

   用途：封装（保存）、隐藏变量，如游戏血量，不能直接访问，得间接访问
   应用：
      - 模块

      ```js
         // 一个模块应该具有私有属性、私有方法和公有属性、公有方法。
         // 而闭包能很好的将模块的公有属性、方法暴露出来。
         var myModule = (function (window) {
            let name = "echo";
            function getName() {
               return name;
            }
            return {
               name,
               getName
            }
         })(window);

         console.log( myModule.name ); // echo
         console.log( myModule.getName() ); // echo
      ```

      - 延时器(setTimeout)、计数器(setInterval)
      这里简单写一个常见的关于闭包的面试题。

      ```js
      for( var i = 0; i < 5; i++ ) {
         (function(j){
            setTimeout(() => {console.log(j)}, 1000)
         })(i)
      }
      ```

12. 立即执行函数和闭包的区别：
   - 立即执行函数和闭包没有关系，虽然两者会经常结合在一起使用，但两者有本质的不同
   - 立即执行函数只是函数的一种调用方式，只是声明完之后立即执行，这类函数一般都只是调用一次（可用于单例对象上），调用完之后会立即销毁，不会占用内存
   - 闭包则主要是**让外部函数可以访问内部函数的作用域**保存保护变量，也减少了全局变量的使用，保证了内部变量的安全，但因被引用的内部变量不能被销毁，增大了内存消耗，使用不当易造成内存泄露

13. 如何翻转 DOM？冒泡和捕获机制，以及实际应用？

   冒泡和捕获机制：就是 DOM 模型； 事件流：捕获（阶段（`window` → `document` → `html` →`body`→目标元素））→ 目标阶段 → 冒泡（阶段）

   应用：**事件代理**（委托） → ul 代理 li 的点击，通过 target.enevt 得到具体那个 li 点击的；优点是可以**监听动态生成的元素**，省监听器，省内存，缺点：得判别监听的元素是不是正确。

   如果点击元素恰好是监听元素，那么捕获不ー定在冒泡之前，[顺序是由监听顺序决定的](https://jsbin.com/raqakog/1/edit?js,console,output)

   Event对象常用应用
   - `event.preventDefault()`：阻止默认行为（a标签：设置了click事件，阻止其默认跳转）⭐
   - `event.stopPropagation()`：阻止冒泡 stopPropagation ⭐
   - `event.stoplmmediatePropagetion()`:事件优先级设置
   - `event.currentTarget`: 当前绑定事件元素，父级元素 （事件代理） ⭐
   - `event.target`：获取具体点击元素 ⭐

14. 移动端的触摸事件了解吗？

- touchstart 触摸开始，多点触控，后面的手指同样会触发; touchmove：接触点改变，滑动时；touchend：触摸结束，手指离开屏幕时；touchcancel：触摸被取消，当系统停止跟踪触摸的时候触发
- 模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。

1. 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣

   > Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

   1. Object.prototype.toString.call() 返回 [object Type],常用于判断浏览器内置对象
   2. instanceof 是通过判断对象的原型链中是不是能找到类型的 prototype。
   3. [Array.isArray()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray) 是ES5新增的方法， 用来判断对象是否为数组，优于 instanceof，可以检测来自 iframe 的数组

1. forEach、for in 、 for of三者的区别
   1. forEach：对数组、dom 列表集合（伪数组）遍历，不能使用 return、break 等中断循环，除非 try catch 异常中断
   2. for in: 遍历对象返回的对象的 key 值，遍历数组返回的数组的下标；遍历对象本身的所有可枚举（enumerable）属性，以及对象从其构造函数原型中继承的属性。
   3. for of：循环遍历可迭代对象，`String`、`Array`、伪数组、`Map` 和 `Set`，它们的原型对象都实现了 @@iterator 方法。

1. 事件，EventBus
   Dom 元素的 on 事件和 addEventListener() 方法的区别：因为 on 事件是个属性，所以只能赋值，赋值就会替换掉；简单说，on 只能绑定一次事件， addEventListener() 可以对一个事件执行多个方法。

   ```js
   function EventBus(){
      this._events = {};
   }
   EventBus.prototype.$on = function(eventName,func){
      if(this._events[eventName]==null){
         this._events[eventName]=[func];
      }
      else{
         this._events[eventName].push(func);
      }
   }

   EventBus.prototype.$emit = function(eventName){
      const callbacks = this._events[eventName];
      if(callbacks){ return; }
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i].apply(this, Array.from(arguments).slice(1));
      }
   }
   EventBus.prototype.$off = function(eventName,func){
      let callbacks = this._events[eventid];
      if (!callbacks) return;
      for (let i = 0; i < callbacks.length; i++) {
        if (callbacks[i] === func) {
          callbacks.splice(i, 1);
        }
      }
   }
   const fun = function (params0, params1) {
      console.log(`hello world ${params0} ${params1}`)
    }
    const fun1 = () => {
      console.log('hello fuck the world')
    }

    const bus = new EventBus();
    bus.$on('sayFun', fun);
    bus.$on('sayFun', fun1);

    bus.$emit('sayFun', '这个世界', '会好吗？');

    bus.$off('sayFun', fun);

    bus.$emit('sayFun');
   ```

1. 何时使用 `==`:判断一个对象是否 `null` or `undefined` 时，jQuery 推荐的写法

    ```js
    if (obj.a == null) {
     // 这里相当于 obj.a === null || obj.a === undefined 的简写形式
    }
    null 只和 undefined 相互比较时为 true，其他都为 false
    null == undefined → true
    null === null → true
    null === undefined → false
    虽然 null 转换数字为 0，但 null == 0 是不会转换的 → false ⭐️
    undefined 转换数字为 NaN
    ```

### Vue

1. 渐进式开发：搭积木，我们可以根据需求，用最小、最快的成本一步步搭建项目，如使用 Vue，不必一开始就用 Vue 所有的全家桶，根据场景，合理使用 Router、Vuex 等。Vue 是一个以数据响应式为核心的一个框架，核心思想把所有数据放入一个对象里面，你去操作这个对象，对象去改变数据，监听这个改变去改变 UI。

1. 解释一下 MVVM

没有前后端概念时候，开发页面是后台代码逻辑、html、Css、JavaScript 都是在同一个页面，好处是开发简单快捷，缺点后期很难维护。为了开发更便捷、后期维护简单、前后端职责清晰，便衍生出 MVC 开发模式和框架，前端展示以模板的形式出现。
业务模型、视图、控制器分层，职责清晰，代码易维护。随着 ajax 技术发展，前后端的职责就更加清晰了。前端不但要负责数据展示，也要负责数据整合与后端交互，随着前端的业务越来越复杂，前端借鉴了 MVC，发展出了 MVP，MVVM 架构。

- 这三者都是框架模式，它们设计的目标都是为了**解决 Model 和 View 的耦合**问题。
- MVC 模式出现较早主要应用在后端，如.NET MVC等，在前端领域的早期也有应用，如 Backbone.js，它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题，很多开发者都会在 view 中写一些逻辑代码，逐渐就导致 view 中的代码越来越庞大，而 controller 变的越来越单薄。
- MVP 模式在是 MVC 的进化形式，Presenter 作为中间层负责 M V 通信，解決了两者耦合问题，但 P 层过于臃肿会导致维护问题。
- MVVM 模式在前端领域有广泛应用，它不仅解決 MV 耦合问题，还同时解決了维护两者映射关系的大量繁杂代码和 DOM 操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。

- View 视图是指用户看到并与之交互的界面。比如由 html 元素组成的网页界面，或者软件的客户端界面。MVC 的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。
- model 模型是指模型表示业务规则。在 MVC 的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
- controller 控制器是指接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。

- **View 传送指令到 Controller**
- **Controller 接收指令、数据传给 Model**
- **Model 进行逻辑判断、数据存储，根据业务逻辑选择不同的 View，将结果返回给用户；用户得到反馈，所有通信都是单向的。**

![](https://cdn.jsdelivr.net/gh/w3ctim/picBed/blog/notes/20200526174732.png)

- 前端早起 MVC 是指Model,View,Controller,是一种代码架构模式，将代码分成三块。
  1. Model：用于处理数据的操作，包括数据逻辑、数据请求与数据存储等功能。
  2. View：用于展示代码在页面哪一块，查找标签，负责用户界面。
  3. Controller：负责处理 View 事件并更新 Model，也负责监听 Model 的变化并更新 View。 Controller 控制其他所有流程。

   ```js
   var model={  // 数据操作
      init:function(){},   // 初始化
      fetch:function(){}, // 接收数据
      save:function(){}   // 储存数据
   }
   var view=document.querySelector('#xxx')  // 查找页面中的标签
   var controller={
         view:null,
         model:null,
         init:function(view,model){  // 初始化控制器
            this.view=view
            this.model=model
            this.model.init()
            this.bindEvent()
   }
   bindEvent:function(){}  // 事件函数
   }
   ```

早期没有前后端概念时候，开发页面是后台代码逻辑、html、Css、JavaScript 都是在同一个页面，好处是开发简单快捷，缺点后期很难维护； 后来就有了 MVC 开发模式，分别为 view 视图层指用户看到并与之交互的界面，Model：用于处理数据的逻辑操作、存储等功能，controller：指接受用户的输入并调用模型和视图去完成用户的需求。这样分层职责清晰，代码易维护很好的**解决 Model 和 View 的耦合**。随着 ajax 技术发展，前后端的职责就更加清晰了，前端处理的事情越来越多，前端就借鉴 MVC 模式开发，但现实前端使用 MVC 模式开发很不灵活，很繁琐，例如一事件操作，都进过这样的流程就不那么便捷了。后来就有 MVVM 模式，MVVM 与 MVC 最大的区别就是：**ViewModel 实现数据响应式机制，View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动更改，这样就很好解决 MV 耦合问题**

[前端MVC/MVVM模式特点及区别](https://blog.csdn.net/qq_36228442/article/details/79470408)

MVC 目的是让工程师 关注 Model 层，而不是 UI。

1. v-if 和 v-for的优先级
v-for 优先级跟高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐同时使用，应该使用计算属性去除不要渲染的项

1. `Object.defineProperty()` 不支持数组,调用原生方法操作数组是不会触发视图的, Vue 就把数组上不会返回新数组的 7 个原型方法（push、pop、shift、unshift、splice、sort、reverse）都重写了，7个[称为变异方法](https://v1-cn.vuejs.org/guide/list.html#%E6%95%B0%E7%BB%84%E5%8F%98%E5%8A%A8%E6%A3%80%E6%B5%8B). 其他的非变异方法就是返回一个的数组，用新的数组替换旧数组视图就更新了：

   ```js
   example1.items = example1.items.filter(function (item) {
    return item.message.match(/Foo/)
   })
   ```

⭐ 但无法操控数组的`length`,也不能用索引修改，如果需要用数组下标修改数组并实现响应式数据变化，Vue 提供了 `$set()` 及 `$remove()` 观察数组方法（注意非 `$delete` 方法），就不推荐 splice。

   ```js
   // 与 `example1.items[0] = ...` 相同，但是能触发视图更新
   example1.items.$set(0, { childMsg: 'Changed!'})
   ```

  Vue3 使用`Proxy` 来替换`Object.defineProperty()`
   `Proxy`直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于`Object.defineProperty`。
   `Proxy`可以直接监听数组的变化

1. 组件 data 为什么是个方法，根组件不需要：组件是有可能复用的，使用方法返回对象是一个新的对象地址，如果使用一个 data 会造成污染；根组件是单例的。

1. 虚拟 DOM 实现目的，原理？虚拟 DOM 的实现原理主要包括以下 3 部分：

vDOM 最初的目的，就是更好的跨平台，比如 Node.js 就没有 DOM，如果想实现 SSR（服务端渲染），那么一个方式就是借助 VDOM 实现。
原生 JS 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行 10 次。

**VDOM 是适合频繁部分修改 dom 的场景，纯插入和删除可能性能不如 raw。**

- **用 js 模拟 DOM 树，对真实 DOM 进行抽象**；有了虚拟 DOM 就不用操作
- diff 算法 — 比较两棵虚拟 DOM 树的差异；**深度优先，同层比较**；先一级一级比较的子节点，如果哪层新子节点没有数据，对应的旧层级有数据，就直接删除。
- patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

1. key 的作用：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以**更准确、更快速**。不带 key 同一级，在 sameNode 函数 可能会覆盖。

1. minxin：混入，解决代码复用问题；慎用，不同的 `Mixin` 中的方法可能会相互冲突，相互耦合，不利于代码维护

1. Vue.use()：使用插件，Vue 的插件必须提供 `install(Vue,options)` 方法，插件的内容可以是全局方法，自定义指令，过滤器，添加 Vue 原型（实例）上方法，或者一个库。

1. 组件化理解：是独立、可复用的**代码组织单元**。合理的划分组件，有助于提高应用性能，遵循单向数据流的原则。

1. 模块化理解：**系统**逻辑模块，相对于**业务**。

1. 单向数据流：**父级 prop 的更新会向下流动到子组件中，但是反过来则不行，目的：防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解**。
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。
这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

1. computed 和 watch 的区别和运用的场景？

   - computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；默认只有 getter，[不过在需要时你也可以提供一个 setter](https://vuex.vuejs.org/zh/guide/forms.html)
   - watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

   运用场景：
   当我们需要进行**数值计算**，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

   当我们需要在**数据变化时执行异步或开销较大的操作时**，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

1. Vue优化：
   1. 路由懒加载，系统打包时候也回缩减体积
   2. keep-alive 缓存页面
   3. 频繁显示或隐藏的用 v-show
   4. v-for 遍历同时避免使用 v-if

1. 路由导航守卫有哪些
   - 全局前置守卫：每次跳转前执行导航守卫方法，`beforeEach(to,from,next())` to：要跳转目标页，from：referrer,`next()` 方法是执行跳转动作，element-admin 在跳转守卫里先判断用户权限,代码路由配置 meta（元信息，其他信息）里添加可以访问的角色 ID，获取拥有的路由地址动态添加到路由对象，`router.addRoutes([...routes])`
   - 路由独享的守卫：`beforeEnter(to,from,next())` 就是单独一个路由配置里
   - 组件内的守卫：

      ```js
      const Foo = {
         template: `...`,
         beforeRouteEnter (to, from, next) {
            // 在渲染该组件的对应路由被 confirm 前调用
            // 不！能！获取组件实例 `this`
            // 因为当守卫执行前，组件实例还没被创建
         },
         beforeRouteUpdate (to, from, next) {
            // 在当前路由改变，但是该组件被复用时调用
            // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
            // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
            // 可以访问组件实例 `this`
         },
         beforeRouteLeave (to, from, next) {
            // 导航离开该组件的对应路由时调用
            // 可以访问组件实例 `this`
         }
      }
      ```

   - 全局后置钩子: `router.afterEach((to, from)=>...)` 与守卫不同的是，这个钩子不会接受 next 函数也不会改变导航本身

1. 都是由浏览器的接口实现的，hash 路由：window.onhashchange 和 history 路由：html5 新的 API history.pushState() 、replayState() 二者仅改变网址,网页不会真的跳转,也不会获取到新的内容,本质上网页还停留在原页面! 只是 pushState 添加一条 history 记录，replayState 是修改当前 history，不会新添加记录，二者都不会触发 onpopstate 事件，需手动操作触发（`history.go(num)`）；注意，同一个文档（页面）的，使用 history.go() 是不会刷新页面的。 pushState 比起 hash 的优点：
   - pushState 设置的新 URL 与当前的 URL 一致也会渲染（刷新）页面，hash 不会
   - 没有丑陋的 `#`,第三方应用可能不支持 `#`
   - pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
   缺点：
   - 怕刷新，手动刷新（重启）浏览器是会请求后台的，如果请求的地址（设置一个子节点）是后台没有对应的路由，则 404，所以也需要后台配置如果是后台找不到，就重定向前端的首页
1. 何时使用 beforeDestory
   1. 可能在当前页面中使用了 `$on` 方法，那需要在组件销毁前解绑。
   2. 清除自己定义的定时器
   3. 解除事件的绑定 `scroll` `mousemove` ....

1. Vuex
   提供一个 Store 仓库（核心），里面可以分 modules 放 store，store 里存储 state（状态，数据）；因为有可能多个组件依赖于同一状态，直接修改状态是很难追踪哪个组件变更的状态，所以修改状态必须使用 mutations 里注册的方法，外部组件在使用 `commit('具体 mutations 里注册的方法名','参数...')`, 易于问题追踪以及提⾼高代码可维护性。

   Getter 可以对 Store 中已有的数据加工处理之后形成新的数据，只是起到包装数据用作，不会修改任何数据，类似 Vue 的计算属性。

   现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。

   每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

   ```js
   // 可使用 vuex 提供 mapState、mapGetters 函数可以映射到当前组件的 computed, mapMutations、mapAations 函数，映射为当前组件的 methods 函数
   import { mapState, mapMutations, mapAations, mapGetters} from 'vuex'
   computed:{
    ...mapState(['count']),
    ...mapGetters(['shouNum'])
   },
   methods:{
      ...mapMutations(['add','addN']),
      ...mapAations(['addSync']),
      // 可以在组件中直接调用 add、addN、addSync，可以再封装方法
      btn2Handle(){
         this.addN(2)
         this.addSync()
      }
   }
   ```

   使用 computed 属性 v-model 绑定 input 时，[注意得使用带有 setter 的双向绑定计算属性](https://vuex.vuejs.org/zh/guide/forms.html)。

1. Vue 源码：

new Vue()，做了什么，Vue 就是一个类

```js
// instance/index.js
function Vue(options){ this._init(options) }

initMixin(options)

// instance/init.js 一堆的初始化工作
let uid = 0;
/*initMixin 就做了一件事情，在 Vue 的原型上增加 _init 方法，构造 Vue 实例的时候会调用这个 _init 方法来初始化 Vue 实例*/
export function initMixin(){
  Vue.prototype._inti=function(options?object){
     const vm = this;
     vm.uid = uid++; // 定义 uid
     // 合并 options
     vm.$options = margeOptions(resolveConstructorOptions(vm.constrctor))
    /*初始化生命周期*/
    initLifecycle(vm)
    /*初始化事件*/
    initEvents(vm)
    /*初始化 render*/
    initRender(vm)
    /*调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件*/
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    /*初始化 props、methods、data、computed 与 watch
     * 其他方法能直接获取 this.data 的值，initData 方法内将 data 上面的属性代理到了 vm 实例上 proxy(vm, `_data`, keys[i])
     */
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    /*调用 created 钩子函数并且触发 created 钩子事件*/
    callHook(vm, 'created')

    if (vm.$options.el) {
      /*挂载组件*/
      vm.$mount(vm.$options.el)
    }
  }
}
```

1. 挂载组件
2. 如果有自定义 render 函数就是用自定义的，没有就根据 template 调用 parse 生成 AST 语法树（parse 正则等方式解析 template 模板中的指令、class、style等数据，形成AST语法树）优化 AST，即对 AST 节点进行静态节点或静态根节点的判断，便于之后 patch 判断，再根据语法树得到的 render 函数,如果 template 不存在的就取 el 的 outerHTML 生成 AST 语法树。。。
3. render 函数最终是通过执行 createElement 方法并返回的 vnode
4. _update 方法的作用是把 VNode 渲染成真实的 DOM，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；

## 性能优化

1. 浏览器的渲染原理是一定会被问到的？

2. 浏览器输入一个 url 之后的过程，以及过程中应用了哪些缓存，如何优化？

3. script 标签和 link 标签的先后顺序对页面加载的影响？

4. async 和 defer 的区别？
     - 都是异步加载，加载时不会阻塞 DOM 渲染；
     - defer：是在 HTML 解析完之后才会执行,如果多个,按照加载的顺序依次执行
     - async：是 JS 脚本加载完成之后立即执行,如果这是 HTML 还未接卸完会阻塞渲染，如果是多个,执行顺序和加载顺序无关

## 计算机网络

1. 解释 TCP/IP 的三次握手和四次挥手？

   三次握手是客户端、服务端**均让对方**知道自己有接收和发送能力最小次数；三次是最少的安全次数，两次不安全，四次浪费资源。

   第一次客户端发送消息到服务端，服务端知道客户端发送的能力，
   第二次服务端发送消息到客户端，客户端就可以知道服务端有**发送和接受**能力，
   第三次客户端再发送请求到服务端，服务端收到，就可以确定双方的接收和发送能力没有问题；

   其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。

   四次挥手：TCP 是全双工信道，就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：

   客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。

   服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。

1. 解释跨域问题以及前端常用的解决方案？

   - JSONP ,动态创建 `<script>` 标签 ，src 一个地址，callback 一个函数，服务器把数据塞入 callback 函数参数里，前端在调用这个函数；缺点：只能使用 GET 请求，大小 4K 不安全，有缓存，需要后端配合；
   - CORS 跨域资源共享
   - 服务器代理
   - WebSocket

1. CORS（跨域资源共享）的细节，哪些是简单请求？哪些是非简单请求？
   1. 后端可配置允许的域、请求方法、请求头。
   2. 简单请求：HEAD（与 GET 类似，只不过服务器响应时不会返回消息体，用于只请求资源的首部，检查超链接是否有效，检查网页是否被修改）、GET、POST，非简单请求：PUT、Delete

1. http 状态码：
    - 100：收到响应，请继续发送请求
    - 200：成功收到响应
    - 204：返回没有响应体的响应
    - 206：内容分批响应
    - 301：永久重定向，与 302 区别，搜索引擎和浏览器（缓存）都将旧的网址替换为重定向之后的网址，下次访问，输入旧地址直接跳转到新地址了，不回去再请求一次旧地址；
    - 308：永久重定向，不允许浏览器将原本为 `POST` 的请求重顶到 `GET` 请求上；
    - 302：临时重定向，一般都实现为 `GET` 到 `GET` 重定向，但是**不能确保** `POST` 会重定向为 `POST`；
    - 307：临时重定向，不允许浏览器将原本 `POST` 的请求重定向到 `GET` 请求上；**307、308则不允许重定向时改变请求 method**；
    - 303：临时重定向，只允许任意请求到 `GET` 的重定向；通常用于将 `POST` 请求重定向到 `GET` 请求；例如上传了一份个人信息，服务器返回 303 响应，将你导向一个上传成功页面；
    - 304：请求的文件没有变化，可以使用缓存的内容；
    - 400：客户端请求有语法错误
    - 401：未登录
    - 403：为授权
    - 404：没有找到文件
    - 500：服务器错误，发生了不可预期的错误
    - 503：临时挂了，等着。。

1. GET 与 POST 区别：
   1. GET 是 URL 传值，长度 4 k 1024个字符，POST：没有长度限制（但不同的浏览器可能 4~10M 限制）
   2. GET 浏览器会记录历史，不安全，Get 没有消息体（但事实上可以设置消息体）
   3. POST 用来写数据，GET 用来读数据，POST 不冥等（幂等的意思就是不管发多少次请求，结果都一样）
   4. 其实没多大区别：语意区别，最大区别是 POST 会请求两次，先请求 header，服务器响应 100 continue，再发送 data，服务器响应200 ok（返回数据）

1. 请求头：request
   - Accept（/2克撒布特/，接受）-EnConding: gzip, deflate, br 告诉服务器可以解压的编码
   - Accept-Langage:zh-Hans-CN 优先语言
   - Connection: keep-alive
   - Cookie: xxx
   - Host:请求的服务器
   - Referer：
   - User-Agent(/A枕特/,gent:绅士)
   -

1. 响应头：response
   - Access（/2克撒丝/,访问）-Control-Allow（/əˈlaʊ/）-Origin: *  允许夸域访问的域名
   - Age：0，创建文件使用的时间
   - Cache-Control: max-age=600 强缓存控制，新版的API
   - Content-Encodeing:gzip 顺带说下 服务器图片格式没必要压缩 / length：1024 / type: test/html;charset=utf-8
   - Expires：过期时间，现在一般首选 Cache-Control，用的是本地时间，所以不靠谱
   - ETag:一般为文件的 hash 值（特征值），下次请求时放入 if-None-Match，发送到服务器再匹配是否是已更新
   - Last-Modified: 最后服务器更新的时间，只能精确粒度秒级，假如某个文件 1 秒内修改了 N 次就无法判断了，需要 ETage 来辅助，注意，与 ETag 是互补关系，不是互斥的，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多，要看具体情况具体使用。
   - Sever:服务器信息

1. HTTP 缓存怎么做?
   - `Cache-Control: max-age=300` (秒) ( *Cache 与 Cash（现金）同音。。。。🤓*)
   - `http://xxx.com/1.js?v=1` 避开缓存

1. Cache-Control 和 Etag 的区别是什么?
     - 强缓存：设置缓存时间，直接使用本地的缓存，不用跟服务器进行通信
        `Expires`(绝对时间): Thu, 21 Jan 2017 18:25:02 GMT
        ⭐`Cache-Control`: max-age=360(秒)
     - 协商缓存：得服务器判断浏览器是否能直接使用本地缓存，304 继续使用
        `Last-Modified` `if-Modified-Since`
        ⭐`Etag` `If-None-Match`

1. 前端存储方式汇总
   - cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。
   - token：登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。
   - xss：跨站脚本攻击
   - **黑客将恶意代码注入到用户的页面中，就可以通过脚本获取用户登录信息（document.cookie,token），去执行别的操作**
   - 目的：获取用户的信息（cookie、token等），在去执行别的操作
   - 预防：`http` `ResponseHeaders` 里 `Set-Cookie`值添加`HttpOnly`指令，**前后端替换关键字,如: `<`为 `&lt;` `>` 为 `&gt;`，用 `innerText`,慎用 innerHTML**

   - **csrf：跨站请求伪造：利用用户已登录状态，冒充用户，欺骗用户浏览器，代替用户操作** 跨站发起请求，浏览器是不管的。
   - 简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。csrf并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。
   - 目的：冒充用户，欺骗用户浏览器，让其以用户的名义进行操作
   - **预防：1. 检查 referer. 2. 各种验证(指纹,短信,密码)**

   csrf 例子：假如一家银行用以运行转账操作的URL地址如下： `http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName` 那么，一个恶意攻击者可以在另一个网站上放置如下代码：`<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">` 如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。

   上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。

   以上面的 csrf 攻击为例：

   cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。
   token：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作。

   WebStorage复习：

   - 跨源数据存储访问（同源策略，顺便复习一下内容安全策略）: WebStorage 不可以，cookie: 本域和父域设置 cookie
   - cookie 为 4KB，而 WebStorage 是 5MB；
   - WebStorage 不会传送到服务器（节省网络流量，相对安全性），**只能字符串**
   - localStorage 生命周期是永久的，关闭页面或浏览器之后 localStorage 中的数据也不会消失。localStorage 除非主动删除数据，否则数据永远不会消失。
   - sessionStorage 的生命周期是在仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的。
   - Web Sql：标准不再更新，关系型，底层是 sqlite；Chrome 中容量 5M，支持同域不同页面共享；版本参数用于控制，如版本不统一报错，不建议使用。
   - indexDB：类似 WebStorage,桌面端 50M 上线，移动端 5M 上线，noSql，同域共享，api复杂，版本概念难理解，可建索引，可配合第三方库使用 **`dexie`**

5. 介绍 HTTPS 握手过程
   1. 客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
   2. web服务器收到客户端请求后, 会将网站的证书，一个公钥（公钥放置在证书内）传送一份给客户端
   3. 客户端收到网站证书后会检查证书的**颁发机构、域名以及过期时间**, 如果没有问题就随机产生一个秘钥
   4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
   5. 之后服务器与客户端使用秘钥加密传输

6. HTTPS 中间人攻击：服务器向客户端发送公钥时，攻击者截获公钥，保留在自己手上，伪造一个公钥给客户端

### 前端工程化

1. package.json 文件作用：是对项目或者模块包的描述，里面包含许多元信息。比如项目名称，项目版本，项目执行入口文件，项目贡献者等等。npm install 命令会根据这个文件下载所有依赖模块。
1. package-lock.json 文件的作用锁定安装时的包的版本号，就是确保所有库包与你上次安装的完全一样，以保证其他人在 `npm install` 时大家的依赖能保证一致。

1. webpack 如何拆分大文件？

   - 使用 code split
   - 写法 import('xxx').then(xxx=>{console.log(xxx)})
   - xxx 模块就是按需加载的
   - 什么是动态链接库: 用 dll 链接的方式提取固定的 js 文件，并链接这个 js 文件

1. webpack 打包的过程? **根据配置的的入口文件 [entry]（一般为 index.js 或 main.js），找到引用（import）模块，根据 loader 转换 module,对当前 module 进行转换后，再解析出它依赖的 module（如果有）, 根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk(大块，/创客/),再把每个 Chunk 转换成一个单独的文件加入到输出列表**

1. webpack 优化：
   1. 开发环境时优化：
      1. HMR：热更新，热模块替换：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块）极大提升构建速度；
      2. source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）；
   2. 生产环境优化：
      1. 缓存：一般是针对 babel 缓存 `loader: 'babel-loader?cacheDirectory'`
      2. tree-sharking（树摇，摇树）：名字很形象，通过摇树把树上枯叶摇下来。又叫：依赖关系解析，就是 webpack 中就是未引用的代码不打包：math.js 有 `add()`、`minus()` 等多个方法，但 xx.js 只 `import {add} from math`,那 `minus()` 的方法代码是不会打包的。前提：
         1. 必须使用 ES6 模块化（import，export）
         2. 开启 production 环境
      3. code split 代码拆分打包：可以将 node_modules 中代码单独打包一个 chunk 最终输出，或自动分析多入口 chunk 中，有没有公共的文件，如果有会打包成单独一个 chunk。

         ```js
            // 最优化 /ˌɑːp.tə.məˈzeʃən/
            optimization:{
               splitChunks:'all'
            }
         ```

      4. import 动态导入(懒加载、预加载)：把某一个文件单独打包成一个 chunk。 注：[import 动态导入](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#%E5%8A%A8%E6%80%81import)，将返回一个 promise

         ```js
         document.getElementById('btn').onclick = function(){
         // 懒加载~：当文件需要使用时才加载~
         // 预加载 prefetch： 会在使用之前，提前加载js文件 I
         // 正常加载可以认为是并行加载（同一时间加载多个文件）
         // 预加载 prefetch： 等其他资源加载完毕，浏览器空闲了，再偷偷加载资源，可能存在兼容性问题
            import(/* webpackChunkName： 'test'， webpackPrefetch： true */'./test')
            .then(({ mul }) => {
               console.log(mul(4，5));
            });
         }；
         ```

      5. happypack 或者 thread-loader ：多进程打包。它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。哪个 loader 需要多进程处理，直接 loader 里写（一般是 babel-loader 和 eslint-loader 需要多进程处理）。在具体的注：需打包的文件如果体积小，打包的时候会比较慢(启动进程需要时间（600ms），进程之间通信也需要时间)，由于 HappyPack 对 file-loader、url-loader 支持的不友好，所以不建议对该 loader 使用。

      6. 大的库文件不打包，利用 `Externals`，放到 CDN 上加载

         ```js
            externals:[
               'jQuery':'$'
            ]
            modules:{
               noParse:/jQuery/, // 不编译
               ...
            }
         ```

      7. dll 动态链接库：提取公共的 js（jQuery，Vue，Vuex，React，React-Dom，polyfill 等），打包后生成 js 文件以及对应的 manifest.json 动态链接库配置文件，里面记录打包后文件的具体库名与路径。DllPlugin 插件负责打包，DllReferencePlugin 插件负责引入打包的后的动态链接库文件内容。只需要编译一次，不会造成重复打包，他会将引用直接指向 dll。与 external 相比更符合模块化思想，会编译一次，exteranal 不会编译，只是一个外部库。相同点都是让某些库不打包。

      8. IgnorePlugin：忽略某些文件，如 moment.js 时间插件引入的很多语言包，`new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)`

   3. webpack 自带的优化：
      - scope-hoisting：作用域提升，代码内定义的一个变量，如果变量能直接计算出来结果，其计算过程不会打包到代码，直接打包其结果。 `let a = 10;let b = 20; console.log(a+b);`  打包后的文件 `console.log(30)`

## 后端

### 进程与线程

进程：CPU 资源分配的最小单位，拥有资源和独立运行，一个进程至少由一个线程构成，一个程序至少由一个进程构成，进程之间通信：IPC
线程：CPU 资源调度的最小单位，同一个进程内的线程共享改进程内容。

单线程方法慢：因为只有一个线程计算异步
多线程方法快：因为多个线程并发计算多线程就是用资源换性能，但并不是线性增长，1 个线程 13000，5 个线程 4269 性能只有 3 倍提升

- 多线程的协调管理额外成本
- 资源也有上限的--5辆车只有3条道

线程并不是越多越好，坑：

1. 无序性：不可预测性，启动、结束无序（CPU 分片）
2. **多线程安全问题**

线程池（Threadpool）
. Netframework2.0(新的CLR) Threadpool：池化资源管理设计思想，线程是一种资源，之前每次要用线程，就去申请一个线程，使用完之后，释放掉；**池化就是做一个容器**，容器提前申请5个线程，程序需要使用线程，直接找容器获取，用完后再放回容器（控制状态），**避免频繁的申请和销毁**；容器自己还会根据限制的数量去申请和释放

1. 线程复用
2. 可以限制最大线程数量

Task.Run(Active)

解决无序性：

1. Task.WaitAll() \ Task.ContinueWhenAll() 与 Promise.all() 用法一致
   Task.WaitAny() \ Task.ContinueWhenAny() 与 Promise.race() 用法一致

2. 使用 async/await 同步的方式编写异步执行代码，也是个语法糖 IL里面没有 async/和 await，就是常规代码
状态机状态切換+递归，就能支持无限层级 await;首先实例化状态，状态是 -1，然后去执行 task 前面的，启动线程去执行 task，判断完成没，没有就把状态重置到 0,让线程递归调用下；自己 return了，回去继续自己的使命，子线程递归回去再次执行状态机动作，包括完成自己的后续动作，如果再遇到 await，又把状态重置为 -1，然后再继续。

多线程安全问题：一段代码，单线程执行和多线程执行结果不一致，就表明有线程安全问题

多线程去访问同一个集合（对象），有问题吗？

```C#
List<int> intList = new List<int>();
for (int i=0: i<10000: i++)
{
   Task.Run(() => //多线程之后，结果就变成小于10000-就是有的数据丢失了
   {
      intList.Add(i)
   }
}
//List是个数组结构，在内存上是连续摆放的，假如同一时刻，去增加一个数据，都是操作同一个内存位置，2个cpu同时发了命令，内存先执行一个再执行一个，就出现覆盖
Thread.Sleep (5000)
Console.Writeline(intList.Count)
```

解决多线程安全问题：
lock，锁：语法糖，等价于监视器（Monitor），锁定一个内存引用地址，所以不能是值类型，也不能是 null

   ```C#
   ...
   // 官方推荐写法
   private static readonly object Lock=new object();
   for (int i=0: i<10000: i++)
   {
      Task.Run(() =>
      {
         // Lock 解决线程安全问题，就是单线程化，Lock 就是保证方法块儿任意时刻只有一个线程能进去，其他线程就排队（这不脱裤子放屁嘛。。）
         lock(Lock)
         {
         intList.Add(i)
         }

      }
   }
   ...
   ```

### 服务器

1. 什么是正向代理，反向代理？

精辟，正向代理隐藏真实客户端，反向代理隐藏真实服务端。

1. Nginx 负载均衡方式有哪些？

- 轮询（默认）：weight（来设置权重）；
- url_hash（第三方）：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效；
- fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。

### `C#`

共有 + 静态类 + 静态方法 + 第一个参数前面加个 this 扩展方法

装箱 就是把“值类型”转换成“引用类型”(Object)；

拆箱 就是把“引用类型”转换成“值类型”；

String：不可变，一旦赋值都是返回一个新的 String 类对象
StringBuilder：动态对象，允许扩充它所封装的字符串中符的数量

### 委托：JS 函数回调

委托本质是一个类，是 C# 实现**回调函数**的一种机制，函数指针

优点：

1. 逻辑解耦，保持稳定
2. 代码复用，可以保证项目的规范性（避免菜鸟写错了，集中管理）

内置委托（语法糖）：16 个重载，17 个参数

- Active：不带返回值，用于回调方法
- Func：带返回值的委托，最后一个参数为返回值，用于模板方法

Lambda 一开始诞生是为委托服务的，后面就千变万化的

Linq:

- Where： 基于委托的代码封装，把数据**筛选**的通用逻辑完成，把**判断**逻辑交给委托传递
- Select：基于委托的代码封装，把数据**转换**的通用逻辑完成，把**转换**逻辑交给委托传递

Linq to object -- Enumerable -- 数据源是内存里面的集合一一传递的委托判断
Linq to Sql-- Queryable-- 数据源在 Sqlserver -- 需要 sql 语句 -- 从**表达式目录树**而来

List 与 IEnumerable 区别，
语法糖一写的时候只需要 IEnumerable + yield ,但是编译后会产生很多代码，是一个状态机模式的

### 字段（成员变量）

- 静态字段表示**类**状态
- 普通字段表示的是**实例**的状态
- 静态构造器运行环境加载时执行，且执行一次，一般为只读字段赋值。
- 属性由字段演变而来，为字段添加 get、set 读写器后称为**属性**，读写器约束字段的行为

### 枚举

枚举 bit 位用法，用一个字段属性多个状态，**用一组标识代表数字，方便开发人员调试，理解**。

### 单例模式

### 工厂模式

### 观察者模式与发布订阅模式

1. 观察者模式：我办了一个补习班，学生想来我这学习，**必须先报名（注册）**。收齐一帮学生，开始教学，**学生们听了我的课及时更新了自己的认知**。我和学生们是有相连，每个人我都认识。被观察得提供一个接受观察者的方法，观察者必须提供被观察者通知的方法，被观察者修改状就循环调用观察者提供个通知方法。观察者和被观察者是**松耦合**的关系。
2. 发布订阅模式：我在某视频站上开了一个专栏，把我的课上传上去，喜欢的同学订阅下。后续我只要把最新课程传到视频站上就好了，学生们听了我的课亦能及时新了自己的认知。我和学生们的联系不是那么大了。我也不需要认识他们。发布者和订阅者是**完全解耦**关系。

区别：后者比前者多了一个类似中转站的东西（姑且称为“中台”或称经纪人【Broker】。），省了我好多事。有学生不愿意学了，直接找中台退订就好了，不用找我说。我发布的新课程也由中台做广播，不用我自己再一个个通知，不会影响到我自己干其他工作。两种模式本质都是一样的，主要关键点都在于注册（添加到注册数组中）和触发（触发注册数组中的内容）

### ORM

通过实例对象的语法，完成关系型数据库的操作的技术，是"对象-关系映射"（Object/Relational Mapping） 的缩写。

- Code First 优点：
  - 项目维护方便，只写代码就行
  - 更换数据库方便

EF: 查询延迟，是为了拼接最终的 Sql 语句，如 `ToList()` 侧查询全部,`FirstOrDefault()` 则添加 `top 1`;

`using(var xx = new XX()){ }` 就是执行 XX 类提供的 `Dispose()`（处理；部署；释放）方法

### AutoMapper作用

AutoMapper 的作用是把一个对象转化为另一个对象，避免每次都去转化。
使用 DTO 实现表现层与领域 Model 的解耦，用 AutoMapper 来实现 DTO 与 领域 Model 的相互转换

### .NET MVC

路由：网站启动时一会执行且只执行一次 Application_Start → 注册路由 → 添加 URL 规则 → 然后请求被正则匹配转发到对应的控制器和 Action

1. 扩展下正则表达式规则，完成基础扩展
2. 扩展路由，能够根据任何的请求信息完成路由匹配
3. 扩展 MVCHandler， 跳出MVC的框架流程，为所欲为

### 编程思想

POP：面向过程编程，符合常规思维，但随着业务复杂度上去了，难以扩展需要。直接的例子如：怎么把大象放入冰箱。
OOP：面向对象编程，它是一种编程思想，确切的说**它是一种考虑问题的方式，先考虑哪些对象参与其中，而不是先考虑步骤**；还是把大象放入冰箱的例子：

OOP 先要做的是考虑几个对象：

- 把大象提取特性到一个类，如动物类；
- 冰箱提取特性到一个类，如家电；
- 人提取特性到一个类，如实施者类；

这样就随着业务的复杂方便的扩展了，比如换成长颈鹿放到冰箱行不行？可以！实例一个长颈鹿就可以了。万物皆对象！不管做多复杂的业务都是，拆解再拆解，拆解到最后都一个个类，各个类之间的交互就是完成小功能，多个功能叠加就是模块，多个模块叠加，就是系统、平台了 → **聚沙成塔**。但是说到这里也不能把 POP 全盘否定，OOP 是程序设计，POP 是内部实现；再日常开发中，类的内部动作还是 POP 的，这是也是很正常的。

封装、继承、多态就是 OOP 产生出来的模式

- 封装：类，一种数据结构、类型，抽象载体
- 继承：复用
- 多态：基于重写机制(virtual → override)，函数成员的具体行为（版本）由对象决定；父类定义个方法不去实现，让继承它的子类去实现，每一个子类有不同的表现

- 重写：继承覆盖重写**父类**方法，参数个数、返回类型都一致，重写父类的方法的具体实现；
- 重载：**同一个类**中的方法与另一个方法同名，但是参数、返回值不同，这种方法称之为重载方法。

什么是接口和抽象类？

具体类 → 抽象类 → 接口：越来越抽象，内部实现东西越来越少。

- 抽象类为**复用而生**：专门作为基类来使用，也具有解耦功能，封装确定的，开放不确定的，推迟到适合的子类去实现
- 接口是“纯虚类”是一个“协约”，只有函数成员；为**解耦而生**，“高内聚，低耦合（依赖）”
- 二者都不能实例化，只能用来声明变量、引用具体类的实例

- 接口隔离原则：使用多个专门的接口比使用单一的总接口要好，避免使用胖借口，一个接口只服务于一个子模块或业务逻辑;
- 单一职责原则：属性与行为分开。

实现原则接口粒度要控制好，过犹不及。

- 低耦合：对象之间**依赖性**
- 高内聚：内聚标志一个模块内各个元素彼此结合的紧密程度，是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。
- **程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。**内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。

特性（Attribute）用于添加**元数据**，如编译器指令和注释、描述、方法、类等其他信息，一个声明性标签是通过放置在它所应用的元素前面的方括号（`[ ]`）来描述的。

反射（镜子里的镜像），给定一个对象，不用实例化，知道其类型，创建出同类型一个对象，并访问其属性，进一步解耦。

- 数据库读取 table 用反射到具体实体

   ```C#
   public static T DrToModel<T>(this DataRow dr){
      // 获取泛型的真实类型
      Type t = typeof(T);
      // 实例化 t 类型变量
      T md = (T)Activator.CreateInstance(t)
      // 获取对象中的属性
      var props = t.GetProperties();
      foreach(var prop in props){
         if(dr.Table.Columns.Contains(prop.Name)){
            prop.SetValue(md,dr[prop.Name])
         }
      }
      return md;
   }
   ```

依赖倒置（反转）原则：面向对象语言程序设计时，高层模块不要依赖于低层模块，二者应该通过抽象来依赖，依赖抽象，而不是依赖细节

- 抽象：接口-抽象类细节：普通类
- 面向细节：写死依赖某个具体类型

面向抽象：可以满足多个类型的诉求，而且可以让高层不受底层扩展影响，细节是多变的，而抽象是稳定的，基于抽象搭建的架构就会相对稳定

- IOC（控制反转）：程序编写的目标：把高层对低层的依赖去掉，换成对抽象的依赖，细节交给第三方来决定（Unity 容器，AutoFac 容器），这就是控制反转；反转的目的是为了降低依赖，增强扩展行，IOC 容器可以理解为一个第三方创建对象的工厂，实现 IOC 容器可以不用重启站点，把对应新版本 DLL 导入站点，修改配置文件即可生效。
- DI（依赖注入）：是实现 IOC 的手段；实现 IOC 时会遇到对象依赖的问题，依赖注入是指在 IOC 创建对象时，通过一定的技术手段（属性标记），去自动完成依赖对象的创建并传入（创建 IBLL 层会引用 IDAL 层，用了 DI 会自动创建 IDAL并传入）！

```C#
IBaseService service = UnityFactory.Create<IBaseService>();
SysUser user = service.Find<SysUser>(3);

// UnityFactory 的 Create 方法就是 实例化 Unity 容器，读取配置文件 生成对应的对象。
```

- Unity 容器：这里容器就是个对象生成器，就是个第三方创建对象的工厂
  - 构造函数注入：`[InjectionConstructor]`，默认调用参数个数最多的,推荐使用构造函数注入，可以不用声明特性，可以在服务层去掉对容器的依赖，.NetCore 内置容器 Servicecollection 就只支持构造函数注入
  - 属性注入：`[Dependency]`
  - 方法注入：`[InjectionMethod]`

Unity 容器配置（`Unity. Configuration` 包）：一个接口实现多个实例，就使用别名区分

AOP：面向切片编程，不破坏封装的前提下，额外扩展功能；用来**抽取公用逻辑，简化业务代码的方式**，灵活使用 AOP 可以让你的业务逻辑代码不会过度臃肿，也是除了继承之外另一种可复用代码的方式；是对 OOP 的一种补充，解决面向对象语言的静态问题，能突破类的限制，动态的扩展类的功能。业务逻辑和系统服务分离。

- 任意扩展功能，聚焦业务逻辑，让程序更简单
- 代码复用，集中管理，减少代码臃肿，但只能扩展通用逻辑，不能新增业务逻辑，如：验证用户合法，性能、日志统计，事物、异常、缓存、IP 等处理。
- AOP 对于 .NET 可以说是改变编程理念，以前写个简单查询必须 `try...catch`、热点数据还得写缓存、还得写日志，不写的话就是裸奔了，但有了 AOP 后就不用重点关注这些了，你负责奔就行了，AOP 负责给你穿衣服。

- 静态实现：代理模式 || 装饰器模式
- 动态实现：dynamic proxy
- 最常用的：Filter，IOC 容器扩展
  - .NET MVC 主要有授权、异常、Action、Result 四个 Filter
  - 实现原理：在 Action 被执行之前，主动检查有没有 Filter 特性，有的话就限制执行这个特性。

泛型：泛化数据类型（听音乐就是泛型，听周杰伦就是具体），表示类型的变量，用它来代替某个实际的类型用于编程，而后通过实际调用时传入或推导的类型来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的

### 分布式异步队列

网站浏览量单位：

- PV: page view 页面浏览量
- UV：独立访客（cookie识别的）
- IP：访问者 IP

网站请求是并发式，100个线程，每个请求需要1s，吞吐量：100 QPS,测试方法：自己写个爬虫，多线程测试一下，loadrunner 工具。

系统扩容过程：因事成人，解决问题

1. 程序，数据库，文件服务器（分布式发文件系统：TFS,GFS,NFS）分开
2. 缓存：使用简单，效果明显，适用广，弊端是实时性等，性能优化的第一步。
3. 集群（水平扩展）：多台服务器完成一台服务器的事儿，共同承担，Nginx 反向代理
4. 集群（垂直切分）：业务（主站，论坛）拆分到多台服务器上。
   1. 数据共享问题：用户状态：单点登录，IndetitiyServer4
   2. A 系统的数据 B 系统要用 → 接口服务
   3. A 系统 步骤1 B 系统 步骤 2 C系统步骤 3 → 队列
5. 分布式：以前一台电脑完成多个步骤分到不同的服务器共同完成
   1. 分布式架构：服务模块的重用服务还能做好高可用，伸缩
   2. 分布式设计的第一要务就是不要分布式
      - 一次请求需要调用多个服务，风险就是指数级
      - 数据一致性
      - 调用复杂性，代码复杂性
   3. 所谓的分布式服务调度框架就是解决这些问题：dubbo zookeeper
6. 微服务：称之为平台架构的风格，是分布式的进化版，分布式架构是被迫的，微服务是主动式的，粒度更细：分布式事务+分布式锁+容器（ docker）

该如何应对大数据高并发？

1. 根据实际情况分析，才能给出解決方案
2. 根据现有的水准再进化,针对性来解决

#### 分布式

集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目,所有的东西都在一个应用里面。

分布式系统是若干独立计算机的集合，**原来由一台计算机完成的事儿，现在由多台计算机分步骤，合作完成。**这里得注意区分与集群的区别：狭义上集群是**原来由一台计算机完成的事儿，现在由多台计算机共同承载，每台服务器都是独立的。**广义上集群也是分布式。

分布式是系统架构演化必然到达的，应对**大数据、高并发**必备的

> 备注：分布式系统的第一要务就是不要分布式!

##### CAP 定理：分布式系统的三个指标

- **C**onsistency 一致性：写操作之后的读操作，必须返回该值；
- **A**vailability 可用性：只要收到用户的请求，服务器就必须给出回应；
- **P**artition tolerance 分区容错：分布式系统下，网络是不可靠的。

> 怎么保证一致性？那就得锁数据了，锁住了数据没有了可用性。所以只要用了分布式，P 总是成立的，剩下的 C 和 A 无法同时做到，这就得根据业务需求取舍了；但是分布式下**可用性**才是最总要，对于大多数系统来说可用性是基石。

##### Base 理论

BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。

- 基本可用（不能阻塞）：系统，出现了不可预知的故障，但**不能阻塞**，还是能用：
  - 响应时间上的损失：正常情况下 0.5 秒返回结果，而基本可用的可以在 1 秒作用返回结果。
  - 功能上的损失：电商，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
- 软状态（中间状态）：相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。软状态指的是：允许系统中的数据存在**中间状态**，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。
- 最终一致性：数据不可能一直是软状态，在期限过后，应当保证所有副本保持数据一致性。从而达到**数据的最终一致性**。这个时间期限取决于网络延时，系统负载，数据复制方案设计等等因素。

BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的。

###### 分布式系统之 CP 模式，强一致性解决方案

- 2PC（two-phase commit protocol） 既分两个阶段提交，依靠第三方协调者（事务管理器）：

   1. 投票阶段（voting phase）：各参与者会处理各自事务，模拟出零时数据、日志，并锁住操作数据，将操作结果通知协调者；

   2. 提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；

   ```C#
   using(TransactionScope ts = new TransactionScope())
   {
      // 投票阶段  两台不同数据库
      sqlHelper1.TransferAdd(10000);
      sqlHelper2.TransferRedcue(10000);
      // 此时数据被锁住阻塞，放弃了可用性

   // 提交阶段
      ts.Complete();
   }
   ```

   缺点：很多，最致命缺点：协调者提交阶段，只有一部分参与者接受到了 commit 请求，出现了数据不一致性的现象。

- 3PC（three phase commit）

即三阶段提交，是2阶段提交的改进版，其将二阶段提交协议的“准备阶段”一份为二，形成了cancommit，precommit，do commit三个阶段。

#### 分布式系统之 AP 模式 分布式事务：基于 MQ 分布式事务，本地消息表，保证数据的最终一致性

##### 事务

1. **A**tomicity 原子性 一个事务必须是不可分割最小单元，要么全提交成功，要么全回滚失败；
2. **C**onsistency 一致性：数据状态一致性，A 银行扣了钱，B 银行必须得收到钱；
3. **I**solation 隔离性：多个并发事务之间相互隔离，不能互相干扰，分级别，参看事务隔离级别；
4. **D**urability 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中，如果还没写入磁盘，就宕机了，也可以恢复数据。

银行的跨行转账就是分布式事务

1. 上有投递消息
2. 下游获取消息
3. 上有投递稳定性
4. 下游接受稳定性

#### 异步队列

主要处理高并发，数据库压力大（一般就是 数据的 IO 瓶颈，导致宕机），全民黑客（抢票、刷票）DDos 攻击。

流程解析：从客户端直接请求服务器，服务器处理再返回结果变成 请求 → 返回等待信息 → 入队 → 处理 → 再查询 → 得到结果

优势：同步变异步

1. 处理速度快，起码千倍提升吞吐量，**解决流量爆发问题** - **削峰**
2. **高可用**，系统不会挂掉（企业的生命线）
3. 易扩展，物理解耦，把接受请求和处理请求完全分开
4. 重试机制 → 分布式事务

缺陷：异步就是异步，没有同步的体验

队列框架：

1. RabbitMQ：开源、轻量级、开箱即用、易部署、易集群；
2. Redis-List
3. RocketMQ: 阿里的，主要是 Java
4. Kafka：不适合做业务，做大数据，人工智能
5. MSMQ：微软的，笨重，不支持跨平台

队列两种模式：

- 生产消费者：一个消息一次处理，如：抢票，秒杀（隔离请求与数据库）
- 发布订阅模式：一个消息订阅者各处理一次，如：抢红包

队列还能干啥？

1. 对接：两个系统间，夸进程通信，重试机制，失败可再试 → 分布式事务；
2. 顺序执行并发任务，如：发邮件，定时任务（订单 24 小时取消）
3. 管道通信，如：IIS 请求就是 Queue → 最大连接数概念

### 负载均衡

因为集群，需要入口，然后转发，所以负载均衡

#### DNS 负载均衡

优点：高效，就近原则
缺点：只能寻轮，独立 IP 贵，错误难发现

#### 硬件负载均衡

F5、Array、Netscale等，硬件 + 软件打包
优点：性能高，稳定好，厂商支持
缺点：省心不省钱，难以扩展，一般壕公司用

#### 软件负载均衡

LVS：Linux Virtual Server 基于网络协议第 4 层（传输层）协议（ip + port）轮询转发(不能根据报文信息转发)，更底层更高效，配置很难

HAProxy 基于网络协议第 4 层 / 7层（应用层）Http 协议 Http 信息（header），转发就更灵活了，非常强大，也不太好配

#### Nginx 负载均衡（主流）

支持策略：

- 轮询（默认）
- 加权轮询（weight）
- ip hash：同一，IP 地址读取同一个服务器，可以很好利用缓存（Session），公司内部不推荐使用
- fair：根据服务器响应情况做分配，不推荐，不稳定
- url hash：单点登录可以用到

用户持久化：

- IP-Hase：局限性强
- Seesion 共享：Inproc / StateServer / **SqlServer / Redis**(专门有个 Redis-Session 扩展)
- 基于 HTTPHeader：Cookie / Token（JWT/IdentiryServer 4）

### 分布式带来问题及应用场景

问题

1. 分布式锁
   单进程下，多线程操作同一个对象，可以用 lock 锁保证只有一个进程能进入；
   多进程（分布式）下，如何保证该对象在任意时刻只能一个线程进入呢？
   变量 A 是有状态的，**不同服务器进程内跨进程的互斥机制来控制共享资源的访问**，这就是分布式锁

   ![分布式锁](https://cdn.jsdelivr.net/gh/w3ctim/picBed/blog/back/20200515154639.png)

   实现：必须依赖第三方
   - 基于数据库实现（现在基本不用了）
      1. 在数据库中创建一个表
      2. 表中包含详细描述方法的字段
      3. 创建唯一素引
      4. 执行某个方法，先插入数据，成功插入则获取锁5执行完成后删除对应的行数据释放锁
   - 基于Reds实现
     1. `setnx(key, value）`获取锁
     2. `expiret` 命令为锁添加一个超时时间
     3. `delete(key）` 释放锁
      问题：
        1. setnx，expiret 有间隔，
        2. A 加锁，执行慢，超过，锁自动释放，这时 B 也获取锁，A又跑来把锁释放了，value 做成 guid，要比较再 delete，在执行，B也在执行，违背了锁的问题，解决方法是续租， A 再来个线程去续命。
2. 保证模块稳定性与伸缩性
   实现：集群，服务注册发现（Consul）
3. 全文搜索
   搜索少不了的，而且是非规范性搜索不是严格匹配数据库的数据我爱我的家-->我爱我家
   关系型数据库也能做到，`Iike“%我%”or`

   全文检索技术，**分词建索引**，拆 3 个词存储起来，搜索时也分词，4 个词进行搜索，能匹配，不要求完全匹配，就能最大程度上搜索出相关结果，具体解决方案：

   - Lucene 定制
   - Solr
   - **ES** 用的最多

应用场景

1. 秒杀系统
   在高并发下，多个线程并发更新库存，导致库存为负的情况 - **超卖**问题
   1. 基于数据库的锁：悲观锁，无法满足高并发
   2. 乐观锁：version，多个并发只有一个成功一不会超卖，数据库压力大！

   限流：限制请求到达数据库
   防超卖：不能出现库存不够性能高
   解决方案：Redis：Remote Dictionary Server--远程字典服务器，存在内存快速读写
   单线程多进程模型：只有一个执行流，只有一个人办事儿，10wQPS/秒 一没有线程安全问题（原子性）
   数据库 100 个商品一导入 Redis ，请求先走 Redis（性能高），没有就直接失败了（限流）- incr-decr(+1返回余额-1返回余额）（原子性防止超卖）

2. 刷榜
   直播间刷礼物，实时统计排行；统计流水，需要看房间排名第
   张三-房间-总数-天/周/月/年-主播榜-不可能同步更新，事后统计实时，必须实时，实时排行问题
   Redis-(Web之友，多种数据结构，都是为具体的Web间题而生）zSet -- 有序的列表，1 个 key 对一组数组 -- 刷礼物就增加下  key--values+score

### 微服务架构（ Microservice Architecture）

微服务架构是一个用分布式服务拆分业务逻辑，完成解耦的架构模式。

#### SOA 面向服务架构

Service-Oriented Architecture 面向服务架构：是一个组件模型，它将应用
程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。
SOA 是对现有系统的升级改进整合，通过数据总线串联起来。

SOA VS Micro Service

1. SOA 是为重用，微服务是为了重写
2. SOA 更水平，微服务是垂直的
3. SOA 自上而下，微服务自下而上

### docker

优点：

1. 运行环境一致，不会出现“这段代码在我机器上运行没问题啊”的情况；
2. 高效利用系统资源；
   - old：主机 → 主机操作系统 → 虚拟
   机 → 多个虚拟机 → 应用；
   - docker：主机 → 操作系统 → docker（引擎） → 应用。
3. 更轻松的迁移，无论是物理机、虚拟机、公有云、私有云其运行结果都是一致的；

## 数据库 & 读写分离负载均衡

元数据：描述数据的数据。个人信息是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。
主数据（Master Data）指系统间共享数据（例如，客户、供应商、账户和组织部门相关数据）

### 事务隔离级别

隔离性级别：隔离级别越高,读操作的请求锁定就越严格,锁的持有时间久越长;所以隔离级别越高,一致性就越高,并发性就越低,同时性能也相对影响越大

- 脏读：事务 A 插入或修改一条数据，但还未做提交或回滚处理，B 事务却可以读取该条数据，这条数据就是脏数据。
- 不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。
- 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

> 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 说明                                                                                                                                          |
| ---------------------------- | ---- | ---------- | ---- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到                                                                          |
| 不可重复读（read-committed） | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据                                                              |
| 可重复读（repeatable-read）  | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。Sql Server 默认级别 |
| 串行化（serializable）       | 否   | 否         | 否   | 可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。                                                                      |

### 锁

> 事务 A、B 先后修改一条数据，A 先修改，但未提交，这行数据就被锁定了，B 要修改必须等待 A 提交或回滚即释放锁；事务 A 修改数据检索字段 如果加了索引就锁行，否则锁表。

- 行级锁：开销大，锁表慢，高并发下可并行处理，性能更高。
- 表级锁：锁表快，性能低。

- 悲观锁（数据库提供功能）：相信并发是绝大部分的，并且每一个线程都必须要达到目的的，保证自查询起直到事务结束不会被其他事务读取修改，避免产生脏数据；一定成功，但在并发量特别大的时候会造成很长堵塞甚至超时，仅适合小并发的情况。
  - 共享锁（读/S锁）：其它用户可以并发读取，查询数据，但不能增删改数据。
  - 排他锁（写/X锁）：其他事物对已加锁数据，不能读也不能写

   ```sql
   declare @count as int
   begin tran
      select @count=count from tb WITH(UPDLOCK)
   　　 WAITFOR DELAY '00:00:05' --模拟并发，故意延迟5秒
      update tb set count=@count-1
   commit tran
   ```

- 乐观锁（人为控制功能）：相信并发是极少数的，假设运气不好遇到了，就放弃并返回信息告诉它再次尝试，因为它是极少数发生的；不一定每次都修改成功，但能充分利用系统的并发处理机制，在大并发量的时候效率要高很多。
解决方式是，在表里加一列时间戳或者版本号字段，每次修改前先查询出时间戳，再把修改条件加上时间戳。

   ```sql
   --首先给表加一列timestamp
   ALTER TABLE ttt ADD timesFlag TIMESTAMP NOT null

   然后更新时判断这个值是否被修改
   declare @count as int
   DECLARE @flag AS TIMESTAMP
   DECLARE @rowCount AS int
   begin tran
      select @count=COUNT,@flag=timesflag from ttt
      WAITFOR DELAY '00:00:05' --模拟并发，故意延迟5秒
      update ttt set count=@count-1 WHERE timesflag=@flag --这里加了条件
      SET @rowcount=@@ROWCOUNT  --获取被修改的行数
   commit TRAN

   --对行数进行判断即可
   IF @rowCount=1
      PRINT '更新成功'
   ELSE
      PRINT '更新失败'
   ```

### 读写分离，负载均衡

数据库一般是整个系统中的决定木桶最短那块板，根据 2 / 8 原则读取分离。

读写分离，负载均衡；Sql Server 主要三个对象，主库（写），从库（读，可多个），分发服务；

- 分发服务器：发布订阅形式，主库写完把**日志**对推到发布服务器，主库任务就完成了，然后分发服务器查看那些从库订阅了，即推送更改消息。
  - 快照发布：快照复制指在某一时刻，有延迟；
  - 事务发布：几乎无延迟，秒级，看网络服务器情况

- 从库调度策略：
  - 轮询：定义一个自加一的数，取余从库个数；`i++ % 数据库.count`
  - 权重：按照权重生成随机数，加权随机算法; '6:3:1' `6 : 0 <= Math.random() < 0.6; 3 : 0.6 <= Math.random() < 0.7;...`

- 随着业务不断增加，只有一个主库写的任务越来越重，怎么处理？
  - 分治思想
    - 分库：一库变多库
      - 垂直分库：按业务拆分，如：问答，论坛，博客，新闻
      - 水平分库：按数据拆分，多个库结构一模一样，如：分地区、类别、时间存储
    - 表分区，解决单表数据量大问题（但不好管理）
      - 垂直分表：常读写的字段分一个表，不常写但内容大字段分一个表，如：新闻标题与内容
      - 水平分表：多表结构一模一样，按时间拆分

- 分库分表后，跨库跨表怎么查询？
  1. 避免跨库跨表：设计要注意（租房网肯定分地区，电商得按时间）
  2. 避免不了呢？ 首先不允许 link
     1. 老板喜欢看报表，统揽全局，再搞个总库，晚上同步一实时性要求不高的
     2. 就提供服务获取，不要直连数据库
     3. 分页总数 Nosql 统计数据 / 其他技术(搜索引擎) / 业务妥协（首页不分页，显示更多按钮，点击按钮后再分页）
  3. 业务妥协：技术跟业务是要协作的（升华一下：架构师就是解决问题的，如有无止境的问题，钱能解决就用钱，钱解决不了就用技术，技术不能实现的就只能业务妥协）

### 索引（目录）

建索引的原则：经常为查询条件、排序、与其他表关联字段的；相反：经常更新字段，或重复数据值（性别）不建立索引

如果以存储结构结构来区分，有聚集索引和非聚集索引；如果以数据的唯一性来区分，则有唯一索引和非唯一索引；若以键列个数来区分，有单列索引与多列索引等。

- 普通索引：一个索引单个列，一个表多个单列索引
- 唯一索引：设为唯一约束自动创建唯一索引，索引列值必须唯一，允许为 null
- 主键索引：设为主键就自动创建唯一索引，不能为 null
- 复核索引：一个索引包含多列
- 聚集索引（CLUSTERED）：聚集索引就相当于使用字典的拼音查找，因为聚集索引存储记录是物理上连续存在的，即拼音 a 过了后面肯定是 b 一样。
- 非聚集索引（NONCLUSTERED）：非聚集索引就相当于使用字典的部首查找，非聚集索引是逻辑上的连续，物理存储并不连续。

数据库优化：

小表驱动大表

左连接:left on, 依次遍历左边这个表，查询在右表中是否有对应的记录,如果有对应记录,则匹配,否则显示null

设计数据库三大范式：减少冗余

- 第一范式：每一列都是单一属性数据项，如：`家庭信息`字段：“3口人，北京”，是要拆分为`人口`，`地址`分别存储
- 第二范式：表中只能有一个业务主键，每一列都和主键相关，而不能只与主键的某一部分相关；如：订单表，订单ID，订单时间、金额，订单产品。
- 第三范式：表中不包含已在其它表中已包含的非主关键字信息，部门信息表：包含用户ID，不能再存用户姓名。

适当地反范式，优化查询速度。

分页：

```sql
select top @pagesize * from (
　　　　select *, ROW_NUMBER() OVER(Order by id) AS RowNumber from table_name
　　) as t
　　where RowNumber >（@pageNum-1）* @pageSize

-- or

-- limit：从第 N 条开始读 “，” 分开后为读取多少行
select * from tablename limit (@pageNum-1)*pageSize,@pageSize
```

### Redis 有哪些好处

1. 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持 string，list，set，sorted set，hash
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

Redis 挂了怎么办:

- 哨兵模式：
- Redis Cluster: 分片存储，主从数据库

## 手写 & 算法

1. ajax

   ```js
   function ajax(){
     return new Promise((resolve,reject) => {
         let xhr = new XMLHttpRequest()
         xhr.open('POST', '/xxxx')
         xhr.send('a=1&b=2');
         xhr.onload = function(){
            if(xhr.readyState === 4 && xhr.status === 200){
               resolve(xhr.response);
            }
            else{
               reject("加载失败");
            }
         }
         xhr.onerror = function(){
            reject(this);
         }
      })
   }
   ```

1. URL 参数

   ```js
   const url = 'https://www.baidu.com/s?ie=UTF-8&wd=asdf';
   const obj ={};
   url.replace(/([^?=&]+)=([^?=&#]+)/g,function(match,p1,p2){
      // match 为每次匹配的内容
      // p1 为第一个分组（小括号）匹配内容，p2 为第二个分组匹配内容...可以依次类推
      obj[p1]=p2;
   });
   ```

1. promise

1. 实现 new，apply,call,bind

1. 实现 after 函数，在调用一个函数多少次之后再执行这个函数，一般处理异步

```js
function after(num,callback){
   num=num||0;
   return function(){
      if(--num<1){
         callback();
      }
   }
}
let fn = after(3,function(){console.log('afert')});
fn()
fn()
fn()
```

1. 实现 柯里化 add(1)(2)(3) // → 6

```js
// 🌰 通过闭包，直接存储结果
function add(...args){
    // 第一次调用函数生成一个闭包来储存结果
    let res = 0;
    let fn = function(...args){
        args.forEach(n => res += n);
        return fn;
    }
    fn.toString = function(){
        return res;
    }
    return fn(...args);
}

// 储存每个参数
function add(...arg){
    // 收集的所有参数
    let res = [...arg];
    // 每次调用都返回一个 供下次调用的方法
    let next = function(...arg){
        // 汇集参数，供其他处理
        let totalArg = [...res,...arg];
        return add.apply(null,totalArg);
    }
    // 利用 toString 返回结果
    // 如有其他需求可在 next 再做判断
    next.toString = function(){
        return res.reduce((a,c)=>a+c);
    }
    return next;
}
```

1. 手写冒泡排序、选择排序、快排（二分四路）、计数排序、插入排序、归并排序、时间复制度？ 翻转二叉树。

```js
   // 冒泡
  function bubbleSort(arr) {
      let len = arr.length,temp=null;
      // 外层循环 i 控制比较的轮数
      for (let i = 0; i < len - 1; i++) {
            // 里层循环控制每一轮比较的次数 j  ‘- i’ 就是循环了几次，最大已放入最后，无须再排
            for (let j = 0; j < len - 1 - i; j++) {
               if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                  // 当前项大于后一项 元素交换
                  // temp = arr[j+1];
                  // arr[j+1] = arr[j];
                  // arr[j] = temp;
                  // ES6 解构赋值写法
                     [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
               }
            }
      }
      return arr;
   }
```

1. 给定两组数，分别以链表方式存储，求和？注意进位

1. 数组去重？

   ```js
   var arr = Array.from({length:20},(n,i)=> n = Math.floor(Math.random() * 10))
   // 1
   var newArr = [];
   for(let i=0;i<arr.length;i++){
   if(newArr.indexOf(arr[i])==-1){
      newArr.push(arr[i])
   }
   }
   // 2
   arr.reduce((a,c)=>(!a.includes(c)?a.push(c):null,a),[])
   // 3
   [...new Set(arr)]
   ```

1. 斐波拉契数列

   ```js
   function fibo(count){
      if(count<=1){
         return 1;
      }
      let arr = [1,1];
      let i = count - 2;
      while(i>=0){
         arr.push(arr[arr.length-1]+arr[arr.length-2])
         i--;
      }
      console.log(arr,arr[count])
   }
   fibo(7)// → [1, 1, 2, 3, 5, 8, 13, 21], 21
   ```

## TypeScript

- public ：公有 在当前类里面、子类 类外面都可以访问
- protected：保护类型 在当前类里面、子类里面可以访问，在类外部没法访问
- private ： 私有 在当前类里面可以访问，子类、类外部都没法访问
- 属性如果不加修饰符默认就是公有（public）

数据类型：

- 元组：特殊的数组，必须指定组数元素个数，及每个元素类型即为元组；
- any：任意类型，一般用于获取 DOM 或接受不确定类型值；
- void：无返回值类型
- never：不存在的类型：用于抛出异常和无线循环的函数返回类型

属性借口：约束参数

命名空间和模块的区别：

- 命名空间：内部模块，主要用于组织代码，避免命名冲突。
- 模   块：ts 的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间，与 ES6 模块差不多一致。

装饰器：装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来横向扩展类、属性、方法、参数的功能。
常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器

装饰器的写法：普通装饰器（无法传参）、装饰器工厂 （可传参）
装饰器是过去几年中 JS 最大的成就之一，已是 ES7 的标准特性之一。

装饰器执行顺序：属性 → 方法 → 方法参数 → 类
如果有多个同样的装饰器，它会先执行后面的。
